CREATE SCHEMA Q_<SYSID>
~
CREATE TABLE Q_<SYSID>.EXT_TYPES
(
  SYS_ID VARCHAR(32) NOT NULL,
  DATA_TYPE INTEGER NOT NULL,
  DESCRIPTION VARCHAR(1024)  NOT NULL,
  PRIMARY KEY (SYS_ID, DATA_TYPE)
) TABLESPACE <STORAGE>
~
CREATE TABLE Q_<SYSID>.TYPES
(
  DATA_TYPE INTEGER NOT NULL,
  DESCRIPTION VARCHAR(1024)  NOT NULL,
  PRIMARY KEY (DATA_TYPE)
) TABLESPACE <STORAGE>
~
CREATE TABLE Q_<SYSID>.DATA_IN_MSG
(
  MSG_ID      BIGSERIAL        NOT NULL,
  DATA_VALUE  TEXT             NOT NULL,
  META_INFO   TEXT,
  EXPIRE_DATE TIMESTAMP WITH TIME ZONE,
  PRIMARY KEY (MSG_ID)
) TABLESPACE <STORAGE>
~
CREATE TABLE Q_<SYSID>.DATA_IN
(
  DATA_IN_ID  BIGINT                              NOT NULL,
  DATA_OUT_ID BIGINT                              NOT NULL,
  SYS_ID      VARCHAR(32)                         NOT NULL,
  DATA_TYPE   INTEGER                             NOT NULL,
  RECORD_DATE TIMESTAMP WITH TIME ZONE DEFAULT clock_timestamp() NOT NULL,
  SUBQ_ID     BIGINT DEFAULT 0                    NOT NULL,
  MSG_ID      BIGINT                              NOT NULL,
  REPLACE_ID  VARCHAR(100),
  PRIMARY KEY (DATA_IN_ID)
) TABLESPACE <STORAGE>
~
CREATE UNIQUE INDEX UI_DATA_IN_1 ON Q_<SYSID>.DATA_IN (SUBQ_ID, DATA_IN_ID, DATA_TYPE) TABLESPACE <STORAGE>
~
CREATE UNIQUE INDEX UI_DATA_IN_2 ON Q_<SYSID>.DATA_IN (SUBQ_ID, SYS_ID, DATA_IN_ID, DATA_TYPE) TABLESPACE <STORAGE>
~
CREATE UNIQUE INDEX UI_DATA_IN_3 ON Q_<SYSID>.DATA_IN (REPLACE_ID) TABLESPACE <STORAGE>
~
ALTER TABLE Q_<SYSID>.DATA_IN
ADD FOREIGN KEY (DATA_TYPE)
REFERENCES Q_<SYSID>.TYPES (DATA_TYPE)
~
CREATE TABLE Q_<SYSID>.DATA_IN_LOG
(
  DATA_IN_ID    BIGINT                              NOT NULL,
  DATA_OUT_ID   BIGINT                              NOT NULL,
  SYS_ID        VARCHAR(32)                         NOT NULL,
  DATA_TYPE     INTEGER                             NOT NULL,
  RECORD_DATE   TIMESTAMP WITH TIME ZONE                           NOT NULL,
  SUBQ_ID       BIGINT                              NOT NULL,
  MSG_ID        BIGINT                              NOT NULL,
  TRANSFER_DATE TIMESTAMP WITH TIME ZONE DEFAULT clock_timestamp() NOT NULL,
  REPLACE_ID  VARCHAR(100)
) TABLESPACE <STORAGE>
~
CREATE UNIQUE INDEX UI_DATA_IN_LOG_1 ON Q_<SYSID>.DATA_IN_LOG (TRANSFER_DATE, DATA_IN_ID) TABLESPACE <STORAGE>
~
CREATE TABLE Q_<SYSID>.DATA_IN_LOG_ARCHIVE
(
  DATA_IN_ID    BIGINT                              NOT NULL,
  DATA_OUT_ID   BIGINT                              NOT NULL,
  SYS_ID        VARCHAR(32)                         NOT NULL,
  DATA_TYPE     INTEGER                             NOT NULL,
  RECORD_DATE   TIMESTAMP WITH TIME ZONE                           NOT NULL,
  SUBQ_ID       BIGINT                              NOT NULL,
  MSG_ID        BIGINT                              NOT NULL,
  TRANSFER_DATE TIMESTAMP WITH TIME ZONE                           NOT NULL,
  REPLACE_ID  VARCHAR(100)
) TABLESPACE <STORAGE>
~
CREATE INDEX I_DATA_IN_LOG_ARCHIVE_1 ON Q_<SYSID>.DATA_IN_LOG_ARCHIVE (DATA_IN_ID) TABLESPACE <STORAGE>
~
CREATE INDEX I_DATA_IN_LOG_ARCHIVE_2 ON Q_<SYSID>.DATA_IN_LOG_ARCHIVE (DATA_OUT_ID, SYS_ID) TABLESPACE <STORAGE>
~
CREATE INDEX I_DATA_IN_LOG_ARCHIVE_3 ON Q_<SYSID>.DATA_IN_LOG_ARCHIVE (TRANSFER_DATE) TABLESPACE <STORAGE>
~
CREATE INDEX I_DATA_IN_LOG_ARCHIVE_4 ON Q_<SYSID>.DATA_IN_LOG_ARCHIVE (RECORD_DATE) TABLESPACE <STORAGE>
~
CREATE TABLE Q_<SYSID>.DATA_IN_ERRORS
(
  DATA_IN_ID BIGINT NOT NULL,
  ERROR_DATE TIMESTAMP WITH TIME ZONE DEFAULT clock_timestamp() NOT NULL,
  ERROR_CODE INTEGER DEFAULT 0 NOT NULL,
  ERROR_TEXT TEXT
) TABLESPACE <STORAGE>
~
CREATE INDEX I_DATA_IN_ERRORS_1 ON Q_<SYSID>.DATA_IN_ERRORS (ERROR_DATE) TABLESPACE <STORAGE>
~
CREATE INDEX I_DATA_IN_ERRORS_2 ON Q_<SYSID>.DATA_IN_ERRORS (DATA_IN_ID) TABLESPACE <STORAGE>
~
CREATE INDEX I_DATA_IN_ERRORS_3 ON Q_<SYSID>.DATA_IN_ERRORS (ERROR_CODE) TABLESPACE <STORAGE>
~
CREATE TABLE Q_<SYSID>.DATA_OUT_MSG
(
  MSG_ID      BIGSERIAL        NOT NULL,
  DATA_VALUE  TEXT             NOT NULL,
  META_INFO   TEXT,
  EXPIRE_DATE TIMESTAMP WITH TIME ZONE,
  PRIMARY KEY (MSG_ID)
) TABLESPACE <STORAGE>
~
CREATE TABLE Q_<SYSID>.DATA_OUT
(
  DATA_OUT_ID BIGSERIAL                           NOT NULL,
  SYS_ID      VARCHAR(32)                         NOT NULL,
  DATA_TYPE   INTEGER                             NOT NULL,
  RECORD_DATE TIMESTAMP WITH TIME ZONE DEFAULT clock_timestamp() NOT NULL,
  MSG_ID      BIGINT                              NOT NULL,
  REPLACE_ID  VARCHAR(100),
  TRANS_ID    VARCHAR(50),
  TRANS_SEQ_NO BIGINT,
  TRANS_TTL TIMESTAMP WITH TIME ZONE DEFAULT '3000-01-01 00:00:00' NOT NULL,
  PRIMARY KEY (DATA_OUT_ID)
) TABLESPACE <STORAGE>
~
CREATE UNIQUE INDEX UI_DATA_OUT_1 ON Q_<SYSID>.DATA_OUT (TRANS_TTL, DATA_OUT_ID, DATA_TYPE) TABLESPACE <STORAGE>
~
CREATE UNIQUE INDEX UI_DATA_OUT_2 ON Q_<SYSID>.DATA_OUT (TRANS_TTL, SYS_ID, DATA_OUT_ID, DATA_TYPE) TABLESPACE <STORAGE>
~
CREATE INDEX UI_DATA_OUT_3 ON Q_<SYSID>.DATA_OUT (TRANS_ID) TABLESPACE <STORAGE>
~
ALTER TABLE Q_<SYSID>.DATA_OUT
ADD FOREIGN KEY (SYS_ID, DATA_TYPE)
REFERENCES Q_<SYSID>.EXT_TYPES (SYS_ID, DATA_TYPE)
~
CREATE TABLE Q_<SYSID>.DATA_OUT_LOG
(
  DATA_OUT_ID   BIGINT                              NOT NULL,
  SYS_ID        VARCHAR(32)                         NOT NULL,
  DATA_TYPE     INTEGER                             NOT NULL,
  RECORD_DATE   TIMESTAMP WITH TIME ZONE                           NOT NULL,
  MSG_ID        BIGINT                              NOT NULL,
  TRANSFER_DATE TIMESTAMP WITH TIME ZONE DEFAULT clock_timestamp() NOT NULL,
  REPLACE_ID    VARCHAR(100)
) TABLESPACE <STORAGE>
~
CREATE UNIQUE INDEX UI_DATA_OUT_LOG_1 ON Q_<SYSID>.DATA_OUT_LOG (TRANSFER_DATE, DATA_OUT_ID) TABLESPACE <STORAGE>
~
CREATE TABLE Q_<SYSID>.DATA_OUT_LOG_ARCHIVE
(
  DATA_OUT_ID   BIGINT                              NOT NULL,
  SYS_ID        VARCHAR(32)                         NOT NULL,
  DATA_TYPE     INTEGER                             NOT NULL,
  RECORD_DATE   TIMESTAMP WITH TIME ZONE                           NOT NULL,
  MSG_ID        BIGINT                              NOT NULL,
  TRANSFER_DATE TIMESTAMP WITH TIME ZONE                           NOT NULL,
  REPLACE_ID    VARCHAR(100)
) TABLESPACE <STORAGE>
~
CREATE INDEX I_DATA_OUT_LOG_ARCHIVE_1 ON Q_<SYSID>.DATA_OUT_LOG_ARCHIVE (DATA_OUT_ID) TABLESPACE <STORAGE>
~
CREATE INDEX I_DATA_OUT_LOG_ARCHIVE_2 ON Q_<SYSID>.DATA_OUT_LOG_ARCHIVE (TRANSFER_DATE) TABLESPACE <STORAGE>
~
CREATE INDEX I_DATA_OUT_LOG_ARCHIVE_3 ON Q_<SYSID>.DATA_OUT_LOG_ARCHIVE (RECORD_DATE) TABLESPACE <STORAGE>
~
CREATE TABLE Q_<SYSID>.DATA_OUT_ERRORS
(
  DATA_OUT_ID BIGINT NOT NULL,
  ERROR_DATE TIMESTAMP WITH TIME ZONE DEFAULT clock_timestamp() NOT NULL,
  ERROR_CODE INTEGER DEFAULT 0 NOT NULL,
  ERROR_TEXT TEXT
) TABLESPACE <STORAGE>
~
CREATE INDEX I_DATA_OUT_ERRORS_1 ON Q_<SYSID>.DATA_OUT_ERRORS (ERROR_DATE) TABLESPACE <STORAGE>
~
CREATE INDEX I_DATA_OUT_ERRORS_2 ON Q_<SYSID>.DATA_OUT_ERRORS (DATA_OUT_ID) TABLESPACE <STORAGE>
~
CREATE INDEX I_DATA_OUT_ERRORS_3 ON Q_<SYSID>.DATA_OUT_ERRORS (ERROR_CODE) TABLESPACE <STORAGE>
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.GET_IN_VALUE_3_11(P_SYS_ID VARCHAR(4000) = NULL, P_DATA_TYPES VARCHAR(4000) = NULL, P_SUBQ_ID BIGINT = 0)
RETURNS TABLE(
  ROW_ID      VARCHAR(128),
  DATA_IN_ID  BIGINT     ,
  DATA_OUT_ID BIGINT     ,
  SYS_ID      VARCHAR(32),
  SYS_2_ID    VARCHAR(32),
  DATA_TYPE   INTEGER    ,
  DATA_VALUE  TEXT       ,
  META_INFO   TEXT       ,
  RECORD_DATE TIMESTAMP WITH TIME ZONE,
  EXPIRE_DATE TIMESTAMP WITH TIME ZONE,
  REPLACE_ID  VARCHAR(100)
) SECURITY DEFINER AS $$
DECLARE
  V_SQL VARCHAR(4000);
BEGIN
  V_SQL = 'SELECT DATA_IN.CTID::VARCHAR, DATA_IN_ID, DATA_OUT_ID, SYS_ID, CAST(''<SYSID>'' AS VARCHAR) SYS_2_ID, DATA_TYPE, DATA_VALUE, META_INFO, RECORD_DATE, EXPIRE_DATE, REPLACE_ID FROM Q_<SYSID>.DATA_IN, Q_<SYSID>.DATA_IN_MSG WHERE SUBQ_ID = ' || P_SUBQ_ID || ' AND DATA_IN.MSG_ID = DATA_IN_MSG.MSG_ID';
  IF P_DATA_TYPES IS NOT NULL THEN
    V_SQL := V_SQL || ' AND DATA_TYPE IN (' || REPLACE(P_DATA_TYPES, ';', ',') || ')';
  END IF;
  IF P_SYS_ID IS NOT NULL THEN
    V_SQL = V_SQL || ' AND SYS_ID IN (''' || REPLACE(REPLACE(REPLACE(P_SYS_ID, ';', ','), ' ', ''), ',', ''',''')||''')';
  END IF;
  RETURN QUERY EXECUTE V_SQL || ' ORDER BY DATA_IN_ID ASC LIMIT 1';
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.GET_OUT_VALUE_2_11(P_SYS_ID VARCHAR(4000) = NULL, P_DATA_TYPES VARCHAR(4000) = NULL)
RETURNS TABLE(
  ROW_ID      VARCHAR(128),
  DATA_IN_ID  BIGINT     ,
  DATA_OUT_ID BIGINT     ,
  SYS_ID      VARCHAR(32),
  SYS_2_ID    VARCHAR(32),
  DATA_TYPE   INTEGER    ,
  DATA_VALUE  TEXT       ,
  META_INFO   TEXT       ,
  RECORD_DATE TIMESTAMP WITH TIME ZONE,
  EXPIRE_DATE TIMESTAMP WITH TIME ZONE,
  REPLACE_ID  VARCHAR(100)
) SECURITY DEFINER AS $$
DECLARE
  V_SQL VARCHAR(4000);
BEGIN
  V_SQL = 'SELECT DATA_OUT.CTID::VARCHAR, CAST(NULL AS BIGINT) DATA_IN_ID, DATA_OUT_ID, CAST(''<SYSID>'' AS VARCHAR) SYS_ID, SYS_ID SYS_2_ID, DATA_TYPE, DATA_VALUE, META_INFO, RECORD_DATE, EXPIRE_DATE, REPLACE_ID FROM Q_<SYSID>.DATA_OUT, Q_<SYSID>.DATA_OUT_MSG WHERE DATA_OUT.MSG_ID = DATA_OUT_MSG.MSG_ID AND TRANS_TTL = TO_TIMESTAMP(''01/01/3000'', ''DD/MM/YYYY'')';
  IF P_DATA_TYPES IS NOT NULL THEN
    V_SQL := V_SQL || ' AND DATA_TYPE IN (' || REPLACE(P_DATA_TYPES, ';', ',') || ')';
  END IF;
  IF P_SYS_ID IS NOT NULL THEN
    V_SQL = V_SQL || ' AND SYS_ID IN (''' || REPLACE(REPLACE(REPLACE(P_SYS_ID, ';', ','), ' ', ''), ',', ''',''')||''')';
  END IF;
  RETURN QUERY EXECUTE V_SQL || ' ORDER BY DATA_OUT_ID ASC LIMIT 1';
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.COMMIT_IN_PROCESSING_4(P_DATA_IN_ID BIGINT, P_RECORD_DATE TIMESTAMP WITH TIME ZONE, P_ERROR_TEXT TEXT = NULL, P_ROW_ID VARCHAR(128) = NULL) RETURNS VOID SECURITY DEFINER
AS $$
DECLARE
  V_TRANSFER_DATE TIMESTAMP WITH TIME ZONE;
BEGIN

  V_TRANSFER_DATE := clock_timestamp();

  IF P_ERROR_TEXT IS NOT NULL THEN
    INSERT INTO Q_<SYSID>.DATA_IN_ERRORS (DATA_IN_ID, ERROR_DATE, ERROR_TEXT) VALUES (P_DATA_IN_ID, V_TRANSFER_DATE, P_ERROR_TEXT);
  END IF;

  IF P_ROW_ID IS NOT NULL THEN
    INSERT INTO Q_<SYSID>.DATA_IN_LOG (DATA_IN_ID,
                                       DATA_OUT_ID,
                                       SYS_ID,
                                       DATA_TYPE,
                                       RECORD_DATE,
                                       SUBQ_ID,
                                       MSG_ID,
                                       TRANSFER_DATE,
                                       REPLACE_ID)
    SELECT
        DATA_IN_ID,
        DATA_OUT_ID,
        SYS_ID,
        DATA_TYPE,
        RECORD_DATE,
        SUBQ_ID,
        MSG_ID,
        V_TRANSFER_DATE,
        REPLACE_ID
      FROM Q_<SYSID>.DATA_IN
      WHERE CTID = P_ROW_ID::TID;

    DELETE FROM Q_<SYSID>.DATA_IN WHERE CTID = P_ROW_ID::TID AND RECORD_DATE = P_RECORD_DATE;
  ELSE
    INSERT INTO Q_<SYSID>.DATA_IN_LOG (DATA_IN_ID,
                                       DATA_OUT_ID,
                                       SYS_ID,
                                       DATA_TYPE,
                                       RECORD_DATE,
                                       SUBQ_ID,
                                       MSG_ID,
                                       TRANSFER_DATE,
                                       REPLACE_ID)
    SELECT
        DATA_IN_ID,
        DATA_OUT_ID,
        SYS_ID,
        DATA_TYPE,
        RECORD_DATE,
        SUBQ_ID,
        MSG_ID,
        V_TRANSFER_DATE,
        REPLACE_ID
    FROM Q_<SYSID>.DATA_IN
    WHERE DATA_IN_ID = P_DATA_IN_ID AND RECORD_DATE = P_RECORD_DATE;

    DELETE FROM Q_<SYSID>.DATA_IN WHERE DATA_IN_ID = P_DATA_IN_ID AND RECORD_DATE = P_RECORD_DATE;
  END IF;
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.ROLLBACK_IN_PROCESSING_4(P_DATA_IN_ID BIGINT, P_ERROR_CODE INTEGER, P_ERROR_TEXT TEXT, P_ROW_ID VARCHAR(128) = NULL) RETURNS VOID SECURITY DEFINER
AS $$
BEGIN
    INSERT INTO Q_<SYSID>.DATA_IN_ERRORS (DATA_IN_ID, ERROR_CODE, ERROR_TEXT) VALUES (P_DATA_IN_ID, P_ERROR_CODE, P_ERROR_TEXT);
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.COMMIT_OUT_PROCESSING_3(P_DATA_OUT_ID BIGINT, P_ERROR_TEXT TEXT = NULL, P_ROW_ID VARCHAR(128) = NULL) RETURNS VOID SECURITY DEFINER
AS $$
DECLARE
  V_TRANSFER_DATE TIMESTAMP WITH TIME ZONE;
BEGIN

  V_TRANSFER_DATE := clock_timestamp();

  IF P_ERROR_TEXT IS NOT NULL
  THEN
    INSERT INTO Q_<SYSID>.DATA_OUT_ERRORS (DATA_OUT_ID, ERROR_DATE, ERROR_TEXT) VALUES (P_DATA_OUT_ID, V_TRANSFER_DATE, P_ERROR_TEXT);
  END IF;

  IF P_ROW_ID IS NOT NULL THEN
    INSERT INTO Q_<SYSID>.DATA_OUT_LOG (DATA_OUT_ID,
                                        SYS_ID,
                                        DATA_TYPE,
                                        RECORD_DATE,
                                        MSG_ID,
                                        TRANSFER_DATE,
                                        REPLACE_ID)
    SELECT
      DATA_OUT_ID,
      SYS_ID,
      DATA_TYPE,
      RECORD_DATE,
      MSG_ID,
      V_TRANSFER_DATE,
      REPLACE_ID
    FROM Q_<SYSID>.DATA_OUT
    WHERE CTID = P_ROW_ID::TID;

    DELETE FROM Q_<SYSID>.DATA_OUT WHERE CTID = P_ROW_ID::TID;
  ELSE
    INSERT INTO Q_<SYSID>.DATA_OUT_LOG (DATA_OUT_ID,
                                        SYS_ID,
                                        DATA_TYPE,
                                        RECORD_DATE,
                                        MSG_ID,
                                        TRANSFER_DATE,
                                        REPLACE_ID)
    SELECT
      DATA_OUT_ID,
      SYS_ID,
      DATA_TYPE,
      RECORD_DATE,
      MSG_ID,
      V_TRANSFER_DATE,
      REPLACE_ID
    FROM Q_<SYSID>.DATA_OUT
    WHERE DATA_OUT_ID = P_DATA_OUT_ID;

    DELETE FROM Q_<SYSID>.DATA_OUT WHERE DATA_OUT_ID = P_DATA_OUT_ID;
  END IF;
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.ROLLBACK_OUT_PROCESSING_4(P_DATA_OUT_ID BIGINT, P_ERROR_CODE INTEGER, P_ERROR_TEXT TEXT, P_ROW_ID VARCHAR(128) = NULL) RETURNS VOID SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO Q_<SYSID>.DATA_OUT_ERRORS (DATA_OUT_ID, ERROR_CODE, ERROR_TEXT) VALUES (P_DATA_OUT_ID, P_ERROR_CODE, P_ERROR_TEXT);
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.CHANGE_IN_SUBQ_3(P_SUBQ_ID BIGINT, P_DATA_IN_ID BIGINT, P_ROW_ID VARCHAR(128) = NULL) RETURNS VOID SECURITY DEFINER
AS $$
BEGIN
  IF P_ROW_ID IS NOT NULL THEN
    UPDATE Q_<SYSID>.DATA_IN SET SUBQ_ID = P_SUBQ_ID WHERE CTID = P_ROW_ID::TID;
  ELSE
    UPDATE Q_<SYSID>.DATA_IN SET SUBQ_ID = P_SUBQ_ID WHERE DATA_IN_ID = P_DATA_IN_ID;
  END IF;
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.PUT_OUT_VALUE_9_1(P_SYS_ID VARCHAR(32), P_DATA_TYPE INTEGER, P_DATA_VALUE TEXT, P_META_INFO TEXT = NULL, P_EXPIRE_DATE TIMESTAMP WITH TIME ZONE = NULL, P_REPLACE_ID VARCHAR(100) = NULL, P_TRANS_ID VARCHAR(50) = NULL, P_TRANS_SEQ_NO BIGINT = NULL, P_TRANS_TTL_SECONDS BIGINT = 3600) RETURNS BIGINT SECURITY DEFINER
AS $$
DECLARE
  V_MSG_ID BIGINT;
BEGIN
  INSERT INTO Q_<SYSID>.DATA_OUT_MSG(DATA_VALUE, META_INFO, EXPIRE_DATE) VALUES (P_DATA_VALUE, P_META_INFO, P_EXPIRE_DATE) RETURNING MSG_ID INTO V_MSG_ID;

  IF P_SYS_ID IS NULL OR P_SYS_ID = 'ANY$Y$TEM' THEN
    INSERT INTO Q_<SYSID>.DATA_OUT(SYS_ID, DATA_TYPE, RECORD_DATE, MSG_ID, REPLACE_ID, TRANS_ID, TRANS_SEQ_NO, TRANS_TTL) SELECT SYS_ID, P_DATA_TYPE, clock_timestamp(), V_MSG_ID, P_REPLACE_ID, P_TRANS_ID, COALESCE(P_TRANS_SEQ_NO, V_MSG_ID), (CASE WHEN P_TRANS_ID IS NULL THEN TO_TIMESTAMP('01/01/3000', 'DD/MM/YYYY') ELSE (SELECT COALESCE(MIN(TRANS_TTL), clock_timestamp() + COALESCE(P_TRANS_TTL_SECONDS, 3600) * interval '1 second') FROM Q_<SYSID>.DATA_OUT WHERE TRANS_ID = P_TRANS_ID AND TRANS_TTL < TO_TIMESTAMP('01/01/3000', 'DD/MM/YYYY')) END) FROM Q_<SYSID>.EXT_TYPES WHERE DATA_TYPE = P_DATA_TYPE;
  ELSE
    INSERT INTO Q_<SYSID>.DATA_OUT(SYS_ID, DATA_TYPE, RECORD_DATE, MSG_ID, REPLACE_ID, TRANS_ID, TRANS_SEQ_NO, TRANS_TTL) VALUES (P_SYS_ID, P_DATA_TYPE, clock_timestamp(), V_MSG_ID, P_REPLACE_ID, P_TRANS_ID, COALESCE(P_TRANS_SEQ_NO, V_MSG_ID), (CASE WHEN P_TRANS_ID IS NULL THEN TO_TIMESTAMP('01/01/3000', 'DD/MM/YYYY') ELSE (SELECT COALESCE(MIN(TRANS_TTL), clock_timestamp() + COALESCE(P_TRANS_TTL_SECONDS, 3600) * interval '1 second') FROM Q_<SYSID>.DATA_OUT WHERE TRANS_ID = P_TRANS_ID AND TRANS_TTL < TO_TIMESTAMP('01/01/3000', 'DD/MM/YYYY')) END));
  END IF;

  RETURN V_MSG_ID;
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.PUT_IN_VALUE_9_1(P_SYS_ID VARCHAR(32), P_DATA_OUT_ID BIGINT, P_DATA_TYPE INTEGER, P_DATA_VALUE TEXT, P_RECORD_DATE TIMESTAMP WITH TIME ZONE = NULL, P_SUBQ_ID BIGINT = 0, P_META_INFO TEXT = NULL, P_EXPIRE_DATE TIMESTAMP WITH TIME ZONE = NULL, P_REPLACE_ID VARCHAR(100) = NULL) RETURNS BIGINT SECURITY DEFINER
AS $$
DECLARE
  V_MSG_ID      BIGINT;
  V_ROW_ID      VARCHAR(128);
  V_DATA_IN_ID  BIGINT;
  V_RECORD_DATE TIMESTAMP WITH TIME ZONE;
  V_SUBQ_ID     BIGINT;
BEGIN
    INSERT INTO Q_<SYSID>.DATA_IN_MSG(DATA_VALUE, META_INFO, EXPIRE_DATE) VALUES (P_DATA_VALUE, P_META_INFO, P_EXPIRE_DATE) RETURNING MSG_ID INTO V_MSG_ID;
    BEGIN
        INSERT INTO Q_<SYSID>.DATA_IN(DATA_IN_ID, SYS_ID, DATA_OUT_ID, DATA_TYPE, RECORD_DATE, SUBQ_ID, MSG_ID, REPLACE_ID) VALUES (V_MSG_ID, P_SYS_ID, P_DATA_OUT_ID, P_DATA_TYPE, COALESCE(P_RECORD_DATE, clock_timestamp()), COALESCE(P_SUBQ_ID, 0), V_MSG_ID, P_REPLACE_ID);
        RETURN V_MSG_ID;
    EXCEPTION
        WHEN UNIQUE_VIOLATION
        THEN
        BEGIN
            SELECT CTID::VARCHAR, DATA_IN_ID, RECORD_DATE, SUBQ_ID INTO V_ROW_ID, V_DATA_IN_ID, V_RECORD_DATE, V_SUBQ_ID FROM Q_<SYSID>.DATA_IN WHERE REPLACE_ID = P_REPLACE_ID;
            PERFORM Q_<SYSID>.COMMIT_IN_PROCESSING_4(V_DATA_IN_ID, V_RECORD_DATE, 'Message replaced!', V_ROW_ID);
            INSERT INTO Q_<SYSID>.DATA_IN(DATA_IN_ID, SYS_ID, DATA_OUT_ID, DATA_TYPE, RECORD_DATE, SUBQ_ID, MSG_ID, REPLACE_ID) VALUES (V_DATA_IN_ID, P_SYS_ID, P_DATA_OUT_ID, P_DATA_TYPE, COALESCE(P_RECORD_DATE, clock_timestamp()), COALESCE(V_SUBQ_ID, 0), V_MSG_ID, P_REPLACE_ID);
            RETURN V_MSG_ID;
        END;
    END;
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.SEND_OUT_TRANS_1(P_TRANS_ID VARCHAR(50)) RETURNS VOID SECURITY DEFINER
AS $$
DECLARE
  I RECORD;
BEGIN
--  FOR I IN (SELECT CTID FROM Q_<SYSID>.DATA_OUT WHERE TRANS_ID = P_TRANS_ID AND TRANS_TTL < TO_TIMESTAMP('01/01/3000', 'DD/MM/YYYY') ORDER BY TRANS_SEQ_NO) LOOP
--    UPDATE Q_<SYSID>.DATA_OUT SET DATA_OUT_ID = NEXTVAL('Q_<SYSID>.DATA_OUT_DATA_OUT_ID_SEQ'), TRANS_TTL = TO_TIMESTAMP('01/01/3000', 'DD/MM/YYYY') WHERE CTID = I.CTID;
--  END LOOP;
    INSERT INTO DATA_OUT(SYS_ID, DATA_TYPE, RECORD_DATE, MSG_ID, REPLACE_ID, TRANS_ID, TRANS_SEQ_NO, TRANS_TTL) SELECT SYS_ID, DATA_TYPE, RECORD_DATE, MSG_ID, REPLACE_ID, TRANS_ID, TRANS_SEQ_NO, TO_TIMESTAMP('01/01/3000', 'DD/MM/YYYY') FROM DATA_OUT WHERE TRANS_ID = P_TRANS_ID AND TRANS_TTL < TO_TIMESTAMP('01/01/3000', 'DD/MM/YYYY') ORDER BY TRANS_SEQ_NO;
    DELETE FROM DATA_OUT WHERE TRANS_ID = P_TRANS_ID AND TRANS_TTL < TO_TIMESTAMP('01/01/3000', 'DD/MM/YYYY');
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.MOVE_DATA_IN_TO_LOG(P_ROWS INTEGER DEFAULT 1) RETURNS INTEGER SECURITY DEFINER
AS $$
DECLARE
   V_COUNT   INTEGER;
   V_ROWID   TID;
   V_LOCKKEY BIGINT;
BEGIN
   V_COUNT := 0;
   SELECT ('X'||SUBSTR(MD5('Q_<SYSID>_MOVE_DATA_IN_TO_LOG'), 1, 16))::BIT(64)::BIGINT INTO V_LOCKKEY;

   IF (SELECT PG_TRY_ADVISORY_LOCK(V_LOCKKEY) = TRUE)
   THEN
      BEGIN
         BEGIN
            FOR I IN 1 .. P_ROWS 
            LOOP
               SELECT CTID INTO V_ROWID FROM Q_<SYSID>.DATA_IN_LOG LIMIT 1;
               IF NOT FOUND THEN
                    EXIT;
               END IF;

               INSERT INTO Q_<SYSID>.DATA_IN_LOG_ARCHIVE
               (
                      DATA_IN_ID,
                      DATA_OUT_ID,
                      SYS_ID,
                      DATA_TYPE,
                      RECORD_DATE,
                      TRANSFER_DATE,
                      SUBQ_ID,
                      MSG_ID,
                      REPLACE_ID
               )
               SELECT DATA_IN_ID,
                      DATA_OUT_ID,
                      SYS_ID,
                      DATA_TYPE,
                      RECORD_DATE,
                      TRANSFER_DATE,
                      SUBQ_ID,
                      MSG_ID,
                      REPLACE_ID
               FROM Q_<SYSID>.DATA_IN_LOG
               WHERE CTID = V_ROWID;

               DELETE FROM Q_<SYSID>.DATA_IN_LOG WHERE CTID = V_ROWID;

               V_COUNT := V_COUNT + 1; 
            END LOOP;
         EXCEPTION
            WHEN OTHERS
            THEN
               NULL;
         END;

         PERFORM PG_ADVISORY_UNLOCK(V_LOCKKEY); 
      END;
   END IF;
   RETURN V_COUNT;
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.MOVE_DATA_OUT_TO_LOG(P_ROWS INTEGER DEFAULT 1) RETURNS INTEGER SECURITY DEFINER
AS $$
DECLARE
   V_COUNT   INTEGER;
   V_ROWID   TID;
   V_LOCKKEY BIGINT;
   V_DATA_OUT_ID BIGINT;
   V_TRANS_ID VARCHAR(50);
BEGIN
   V_COUNT := 0;
   SELECT ('X'||SUBSTR(MD5('Q_<SYSID>_MOVE_DATA_OUT_TO_LOG'), 1, 16))::BIT(64)::BIGINT INTO V_LOCKKEY;

   IF (SELECT PG_TRY_ADVISORY_LOCK(V_LOCKKEY) = TRUE)
   THEN
      BEGIN
         BEGIN
            FOR I IN 1 .. P_ROWS 
            LOOP
               SELECT CTID INTO V_ROWID FROM Q_<SYSID>.DATA_OUT_LOG LIMIT 1;
               IF NOT FOUND THEN
                    EXIT;
               END IF;

               INSERT INTO Q_<SYSID>.DATA_OUT_LOG_ARCHIVE
               (
                      DATA_OUT_ID,
                      SYS_ID,
                      DATA_TYPE,
                      RECORD_DATE,
                      TRANSFER_DATE,
                      MSG_ID,
                      REPLACE_ID
               )
               SELECT DATA_OUT_ID,
                      SYS_ID,
                      DATA_TYPE,
                      RECORD_DATE,
                      TRANSFER_DATE,
                      MSG_ID,
                      REPLACE_ID
               FROM Q_<SYSID>.DATA_OUT_LOG
               WHERE CTID = V_ROWID;

               DELETE FROM Q_<SYSID>.DATA_OUT_LOG WHERE CTID = V_ROWID;

               V_COUNT := V_COUNT + 1; 
            END LOOP;
         EXCEPTION
            WHEN OTHERS
            THEN
               NULL;
         END;

         BEGIN
            FOR I IN 1 .. P_ROWS
            LOOP
               SELECT CTID::VARCHAR, DATA_OUT_ID, TRANS_ID INTO V_ROWID, V_DATA_OUT_ID, V_TRANS_ID FROM Q_<SYSID>.DATA_OUT WHERE TRANS_TTL < clock_timestamp() LIMIT 1;
               IF NOT FOUND THEN
                    EXIT;
               END IF;

               PERFORM COMMIT_OUT_PROCESSING_3(V_DATA_OUT_ID, 'Trans lost! TransId = {' || V_TRANS_ID || '}' , V_ROWID);

               V_COUNT := V_COUNT + 1;
            END LOOP;
         EXCEPTION
            WHEN OTHERS
            THEN
               NULL;
         END;

         PERFORM PG_ADVISORY_UNLOCK(V_LOCKKEY);
      END;
   END IF;
   RETURN V_COUNT;
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.GET_VALUE(P_SYS_ID VARCHAR(4000) = NULL, P_DATA_TYPES VARCHAR(4000) = NULL, P_SUBQ_ID BIGINT = 0)
RETURNS TABLE(
  ROW_ID      VARCHAR(128),
  DATA_IN_ID  BIGINT     ,
  DATA_OUT_ID BIGINT     ,
  SYS_ID      VARCHAR(32),
  SYS_2_ID    VARCHAR(32),
  DATA_TYPE   INTEGER    ,
  DATA_VALUE  TEXT       ,
  META_INFO   TEXT       ,
  RECORD_DATE TIMESTAMP WITH TIME ZONE  ,
  EXPIRE_DATE TIMESTAMP WITH TIME ZONE  ,
  REPLACE_ID  VARCHAR(100)
) SECURITY DEFINER AS $$
    SELECT
          ROW_ID,
          DATA_IN_ID,
          DATA_OUT_ID,
          SYS_ID,
          SYS_2_ID,
          DATA_TYPE,
          DATA_VALUE,
          META_INFO,
          RECORD_DATE,
          EXPIRE_DATE,
          REPLACE_ID
        FROM Q_<SYSID>.GET_IN_VALUE_3_11(P_SYS_ID, P_DATA_TYPES, P_SUBQ_ID);
$$ LANGUAGE SQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.PUT_VALUE(P_SYS_ID VARCHAR(32), P_DATA_TYPE INTEGER, P_DATA_VALUE TEXT, P_META_INFO TEXT = NULL, P_EXPIRE_DATE TIMESTAMP WITH TIME ZONE = NULL, P_REPLACE_ID VARCHAR(100) = NULL, P_TRANS_ID VARCHAR(50) = NULL, P_TRANS_SEQ_NO BIGINT = NULL, P_TRANS_TTL_SECONDS BIGINT = 3600) RETURNS BIGINT SECURITY DEFINER
AS $$
BEGIN
  RETURN Q_<SYSID>.PUT_OUT_VALUE_9_1(P_SYS_ID, P_DATA_TYPE, P_DATA_VALUE, P_META_INFO, P_EXPIRE_DATE, P_REPLACE_ID, P_TRANS_ID, P_TRANS_SEQ_NO, P_TRANS_TTL_SECONDS);
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.COMMIT_PROCESSING(P_DATA_IN_ID BIGINT, P_RECORD_DATE TIMESTAMP WITH TIME ZONE, P_ERROR_TEXT TEXT = NULL, P_ROW_ID VARCHAR(128) = NULL) RETURNS VOID SECURITY DEFINER
AS $$
BEGIN
  PERFORM Q_<SYSID>.COMMIT_IN_PROCESSING_4(P_DATA_IN_ID, P_RECORD_DATE, P_ERROR_TEXT, P_ROW_ID);
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.ROLLBACK_PROCESSING(P_DATA_IN_ID BIGINT, P_ERROR_CODE INTEGER, P_ERROR_TEXT TEXT, P_ROW_ID VARCHAR(128) = NULL) RETURNS VOID SECURITY DEFINER
AS $$
BEGIN
  PERFORM Q_<SYSID>.ROLLBACK_IN_PROCESSING_4(P_DATA_IN_ID, P_ERROR_CODE, P_ERROR_TEXT, P_ROW_ID);
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.SEND_OUT_TRANS(P_TRANS_ID VARCHAR(50)) RETURNS VOID SECURITY DEFINER
AS $$
BEGIN
  PERFORM Q_<SYSID>.SEND_OUT_TRANS_1(P_TRANS_ID);
END;
$$ LANGUAGE PLPGSQL;
~
CREATE ROLE Q_<SYSID>_CLI_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.GET_VALUE(VARCHAR, VARCHAR, BIGINT) TO Q_<SYSID>_CLI_ROLE;
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.PUT_VALUE(VARCHAR, INTEGER, TEXT, TEXT, TIMESTAMP WITH TIME ZONE, VARCHAR, VARCHAR, BIGINT, BIGINT) TO Q_<SYSID>_CLI_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.COMMIT_PROCESSING(BIGINT, TIMESTAMP WITH TIME ZONE, TEXT, VARCHAR) TO Q_<SYSID>_CLI_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.ROLLBACK_PROCESSING(BIGINT, INTEGER, TEXT, VARCHAR) TO Q_<SYSID>_CLI_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.SEND_OUT_TRANS(VARCHAR) TO Q_<SYSID>_CLI_ROLE
~
CREATE ROLE Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.GET_IN_VALUE_3_11(VARCHAR, VARCHAR, BIGINT) TO Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.GET_OUT_VALUE_2_11(VARCHAR, VARCHAR) TO Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.PUT_OUT_VALUE_9_1(VARCHAR, INTEGER, TEXT, TEXT, TIMESTAMP WITH TIME ZONE, VARCHAR, VARCHAR, BIGINT, BIGINT) TO Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.PUT_IN_VALUE_9_1(VARCHAR, BIGINT, INTEGER, TEXT, TIMESTAMP WITH TIME ZONE, BIGINT, TEXT, TIMESTAMP WITH TIME ZONE, VARCHAR) TO Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.SEND_OUT_TRANS_1(VARCHAR) TO Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.COMMIT_IN_PROCESSING_4(BIGINT, TIMESTAMP WITH TIME ZONE, TEXT, VARCHAR) TO Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.COMMIT_OUT_PROCESSING_3(BIGINT, TEXT, VARCHAR) TO Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.ROLLBACK_IN_PROCESSING_4(BIGINT, INTEGER, TEXT, VARCHAR) TO Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.ROLLBACK_OUT_PROCESSING_4(BIGINT, INTEGER, TEXT, VARCHAR) TO Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.CHANGE_IN_SUBQ_3(BIGINT, BIGINT, VARCHAR) TO Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.MOVE_DATA_IN_TO_LOG(INTEGER) TO Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.MOVE_DATA_OUT_TO_LOG(INTEGER) TO Q_<SYSID>_SVC_ROLE
~
CREATE USER Q_<SYSID>_SVC WITH PASSWORD '<PASSWORD>' LOGIN IN ROLE Q_<SYSID>_SVC_ROLE
~
GRANT Q_<SYSID>_SVC_ROLE TO Q_<SYSID>_SVC
~
