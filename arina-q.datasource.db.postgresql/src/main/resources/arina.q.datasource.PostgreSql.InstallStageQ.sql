CREATE TABLE Q_<SYSID>.STAGES_MSG
(
  MSG_ID BIGSERIAL NOT NULL,
  STAGE_XML TEXT,
  META_INFO TEXT,
  PRIMARY KEY (MSG_ID)
)
~
CREATE TABLE Q_<SYSID>.STAGES
(
  REQUEST_ID BIGINT NOT NULL,
  REQUEST_DATE TIMESTAMP WITH TIME ZONE DEFAULT clock_timestamp() NOT NULL,
  MSG_ID BIGINT NOT NULL,
  EXT_ID VARCHAR(50),
  SYS_ID VARCHAR(50),
  STAGE_DATE TIMESTAMP WITH TIME ZONE NOT NULL,
  STAGE VARCHAR(50) NOT NULL,
  ITERATION BIGINT NOT NULL,
  PROCESS_AFTER TIMESTAMP WITH TIME ZONE DEFAULT clock_timestamp() NOT NULL,
  DEP_ID VARCHAR(100),
  PARENT_DEP_ID VARCHAR(4000),
  PRIMARY KEY (REQUEST_ID)
) TABLESPACE <STORAGE>
~
CREATE INDEX I_STAGES_1 ON Q_<SYSID>.STAGES (PROCESS_AFTER, STAGE, SYS_ID)
~
CREATE INDEX I_STAGES_2 ON Q_<SYSID>.STAGES (DEP_ID)
~
CREATE TABLE Q_<SYSID>.STAGES_LOG
(
  REQUEST_ID BIGINT NOT NULL,
  REQUEST_DATE TIMESTAMP WITH TIME ZONE NOT NULL,
  MSG_ID BIGINT NOT NULL,
  EXT_ID VARCHAR(50),
  SYS_ID VARCHAR(50),
  STAGE_DATE TIMESTAMP WITH TIME ZONE NOT NULL,
  STAGE VARCHAR(50) NOT NULL,
  ITERATION BIGINT NOT NULL,
  PROCESS_AFTER TIMESTAMP WITH TIME ZONE NOT NULL,
  DEP_ID  VARCHAR(100),
  PARENT_DEP_ID  VARCHAR(4000),
  TRANSFER_DATE TIMESTAMP WITH TIME ZONE DEFAULT clock_timestamp() NOT NULL,
  FINAL INTEGER DEFAULT 0 NOT NULL CHECK (FINAL IN(1, 0))
) TABLESPACE <STORAGE>
~
CREATE INDEX I_STAGES_LOG_1 ON Q_<SYSID>.STAGES_LOG (REQUEST_ID)
~
CREATE TABLE Q_<SYSID>.STAGES_LOG_ARCHIVE
(
  REQUEST_ID BIGINT NOT NULL,
  REQUEST_DATE TIMESTAMP WITH TIME ZONE NOT NULL,
  MSG_ID BIGINT NOT NULL,
  EXT_ID VARCHAR(50),
  SYS_ID VARCHAR(50),
  STAGE_DATE TIMESTAMP WITH TIME ZONE NOT NULL,
  STAGE VARCHAR(50) NOT NULL,
  ITERATION BIGINT NOT NULL,
  PROCESS_AFTER TIMESTAMP WITH TIME ZONE NOT NULL,
  DEP_ID  VARCHAR(100),
  PARENT_DEP_ID  VARCHAR(4000),
  TRANSFER_DATE TIMESTAMP WITH TIME ZONE NOT NULL,
  FINAL INTEGER NOT NULL
) TABLESPACE <STORAGE>
~
CREATE INDEX I_STAGES_LOG_ARCHIVE_1 ON Q_<SYSID>.STAGES_LOG_ARCHIVE (REQUEST_ID, FINAL)
~
CREATE INDEX I_STAGES_LOG_ARCHIVE_2 ON Q_<SYSID>.STAGES_LOG_ARCHIVE (REQUEST_DATE)
~
CREATE INDEX I_STAGES_LOG_ARCHIVE_3 ON Q_<SYSID>.STAGES_LOG_ARCHIVE (EXT_ID, SYS_ID)
~
CREATE INDEX I_STAGES_LOG_ARCHIVE_4 ON Q_<SYSID>.STAGES_LOG_ARCHIVE (STAGE_DATE, REQUEST_ID)
~
CREATE INDEX I_STAGES_LOG_ARCHIVE_5 ON Q_<SYSID>.STAGES_LOG_ARCHIVE (TRANSFER_DATE)
~
CREATE TABLE Q_<SYSID>.STAGES_ERRORS
(
  REQUEST_ID BIGINT NOT NULL,
  STAGE VARCHAR(50) NOT NULL,
  ITERATION BIGINT NOT NULL,
  ERROR_DATE TIMESTAMP WITH TIME ZONE DEFAULT clock_timestamp() NOT NULL,
  ERROR_CODE INTEGER DEFAULT 0 NOT NULL,
  ERROR_TEXT TEXT
) TABLESPACE <STORAGE>
~
CREATE INDEX I_STAGES_ERRORS_1 ON Q_<SYSID>.STAGES_ERRORS (REQUEST_ID, STAGE)
~
CREATE INDEX I_STAGES_ERRORS_2 ON Q_<SYSID>.STAGES_ERRORS (ERROR_CODE)
~
CREATE INDEX I_STAGES_ERRORS_3 ON Q_<SYSID>.STAGES_ERRORS (ERROR_DATE)
~
CREATE TABLE Q_<SYSID>.STAGES_DEPS
(
  REQUEST_ID BIGINT NOT NULL,
  PARENT_REQUEST_ID BIGINT NOT NULL
) TABLESPACE <STORAGE>
~
CREATE INDEX I_STAGES_DEPS_1 ON Q_<SYSID>.STAGES_DEPS (REQUEST_ID)
~
CREATE INDEX I_STAGES_DEPS_2 ON Q_<SYSID>.STAGES_DEPS (PARENT_REQUEST_ID)
~
ALTER TABLE Q_<SYSID>.STAGES_DEPS ADD
 FOREIGN KEY (REQUEST_ID)
 REFERENCES Q_<SYSID>.STAGES (REQUEST_ID)
 ON DELETE CASCADE
~
ALTER TABLE Q_<SYSID>.STAGES_DEPS ADD
 FOREIGN KEY (PARENT_REQUEST_ID)
 REFERENCES Q_<SYSID>.STAGES (REQUEST_ID)
 ON DELETE CASCADE
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.PUT_STAGE_VALUE_11_1
(
  P_EXT_ID VARCHAR(50),
  P_SYS_ID VARCHAR(50),
  P_REQUEST_ID BIGINT,
  P_STAGE_XML TEXT,
  P_STAGE VARCHAR(50),
  P_PROCESS_AFTER_DELAY BIGINT,
  P_FINAL INTEGER,
  P_DEP_ID VARCHAR(100),
  P_PARENT_DEP_ID VARCHAR(4000),
  P_META_INFO TEXT
) RETURNS BIGINT SECURITY DEFINER
AS $$
DECLARE 
    V_MSG_ID BIGINT;
    V_TRANSFER_DATE TIMESTAMP WITH TIME ZONE;
BEGIN
    INSERT INTO STAGES_MSG
    (
      STAGE_XML,
      META_INFO
    )
    VALUES
    (
      P_STAGE_XML,
      P_META_INFO
    ) RETURNING MSG_ID INTO V_MSG_ID;

    IF P_REQUEST_ID IS NULL
    THEN
        INSERT INTO Q_<SYSID>.STAGES
        (
          REQUEST_ID,
          REQUEST_DATE,
          MSG_ID,
          EXT_ID,
          SYS_ID,
          STAGE_DATE,
          STAGE,
          ITERATION,
          PROCESS_AFTER,
          DEP_ID,
          PARENT_DEP_ID
        )
        VALUES
        (
          V_MSG_ID,
          clock_timestamp(),
          V_MSG_ID,
          P_EXT_ID,
          P_SYS_ID,
          clock_timestamp(),
          P_STAGE,
          1,
          clock_timestamp() + P_PROCESS_AFTER_DELAY * interval '1 millisecond',
          P_DEP_ID,
          P_PARENT_DEP_ID
        );

        IF P_PARENT_DEP_ID IS NOT NULL THEN
          INSERT INTO STAGES_DEPS
          (
                REQUEST_ID,
                PARENT_REQUEST_ID
          )
          SELECT V_MSG_ID, REQUEST_ID
          FROM Q_<SYSID>.STAGES
          WHERE REQUEST_ID < V_MSG_ID AND
                DEP_ID IN (SELECT UNNEST(STRING_TO_ARRAY(REPLACE(P_PARENT_DEP_ID, ';', ','), ',')));
        END IF;
    ELSE
        V_TRANSFER_DATE := clock_timestamp();

        INSERT INTO Q_<SYSID>.STAGES_LOG
        (
          REQUEST_ID,
          REQUEST_DATE,
          MSG_ID,
          EXT_ID,
          SYS_ID,
          STAGE_DATE,
          STAGE,
          ITERATION,
          PROCESS_AFTER,
          TRANSFER_DATE,
          DEP_ID,
          PARENT_DEP_ID
        )
        SELECT
          REQUEST_ID,
          REQUEST_DATE,
          MSG_ID,
          EXT_ID,
          SYS_ID,
          STAGE_DATE,
          STAGE,
          ITERATION,
          PROCESS_AFTER,
          V_TRANSFER_DATE,
          DEP_ID,
          PARENT_DEP_ID
        FROM Q_<SYSID>.STAGES
        WHERE REQUEST_ID = P_REQUEST_ID;

        IF P_FINAL != 0
        THEN
            INSERT INTO Q_<SYSID>.STAGES_LOG_ARCHIVE
            (
              REQUEST_ID,
              REQUEST_DATE,
              MSG_ID,
              EXT_ID,
              SYS_ID,
              STAGE_DATE,
              STAGE,
              ITERATION,
              PROCESS_AFTER,
              DEP_ID,
              PARENT_DEP_ID,
              TRANSFER_DATE,
              FINAL
            )
            SELECT
              REQUEST_ID,
              REQUEST_DATE,
              V_MSG_ID,
              EXT_ID,
              SYS_ID,
              V_TRANSFER_DATE,
              P_STAGE,
              1,
              V_TRANSFER_DATE,
              DEP_ID,
              PARENT_DEP_ID,
              V_TRANSFER_DATE,
              P_FINAL
            FROM Q_<SYSID>.STAGES
            WHERE REQUEST_ID = P_REQUEST_ID;

            DELETE FROM Q_<SYSID>.STAGES
            WHERE REQUEST_ID = P_REQUEST_ID;
        ELSE
            UPDATE Q_<SYSID>.STAGES
            SET
              STAGE_DATE = V_TRANSFER_DATE,
              MSG_ID = V_MSG_ID,
              STAGE = P_STAGE,
              ITERATION = 1,
              PROCESS_AFTER = V_TRANSFER_DATE + P_PROCESS_AFTER_DELAY * interval '1 millisecond'
            WHERE REQUEST_ID = P_REQUEST_ID;
        END IF;
    END IF;

    RETURN COALESCE(P_REQUEST_ID, V_MSG_ID);
END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.GET_STAGE_VALUE_3_10(P_STAGE VARCHAR(32), P_SYS_ID VARCHAR(32) DEFAULT NULL, P_RECORDS INTEGER DEFAULT 1)
RETURNS TABLE
(
  ROW_ID VARCHAR(128),
  EXT_ID VARCHAR(50),
  SYS_ID VARCHAR(50),
  REQUEST_DATE TIMESTAMP WITH TIME ZONE,
  STAGE_DATE TIMESTAMP WITH TIME ZONE,
  REQUEST_ID BIGINT,
  STAGE_XML TEXT,
  META_INFO TEXT,
  STAGE VARCHAR(50),
  ITERATION BIGINT
) SECURITY DEFINER AS $$
      SELECT STAGES.CTID::VARCHAR, EXT_ID, SYS_ID, REQUEST_DATE, STAGE_DATE, REQUEST_ID, STAGE_XML, META_INFO, STAGE, ITERATION
      FROM Q_<SYSID>.STAGES, Q_<SYSID>.STAGES_MSG
      WHERE PROCESS_AFTER <= clock_timestamp() AND
            STAGE LIKE P_STAGE AND
            (SYS_ID = P_SYS_ID OR P_SYS_ID IS NULL) AND 
            STAGES.MSG_ID = STAGES_MSG.MSG_ID AND
            NOT EXISTS (SELECT 1 FROM Q_<SYSID>.STAGES_DEPS WHERE STAGES_DEPS.REQUEST_ID = STAGES.REQUEST_ID)
      ORDER BY PROCESS_AFTER ASC LIMIT P_RECORDS;
$$ LANGUAGE SQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.GET_FINAL_STAGE_VALUE_1_10(P_REQUEST_ID BIGINT DEFAULT 1)
RETURNS TABLE
(
  ROW_ID VARCHAR(128),
  EXT_ID VARCHAR(50),
  SYS_ID VARCHAR(50),
  REQUEST_DATE TIMESTAMP WITH TIME ZONE,
  STAGE_DATE TIMESTAMP WITH TIME ZONE,
  REQUEST_ID BIGINT,
  STAGE_XML TEXT,
  META_INFO TEXT,
  STAGE VARCHAR(50),
  ITERATION BIGINT
) SECURITY DEFINER AS $$
      SELECT STAGES_LOG_ARCHIVE.CTID::VARCHAR, EXT_ID, SYS_ID, REQUEST_DATE, STAGE_DATE, REQUEST_ID, STAGE_XML, META_INFO, STAGE, ITERATION
      FROM Q_<SYSID>.STAGES_LOG_ARCHIVE, Q_<SYSID>.STAGES_MSG WHERE STAGES_LOG_ARCHIVE.MSG_ID = STAGES_MSG.MSG_ID AND REQUEST_ID = P_REQUEST_ID AND FINAL = 1;
$$ LANGUAGE SQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.COMMIT_STAGE_PROCESSING_8(P_STAGE_DATE TIMESTAMP WITH TIME ZONE, P_REQUEST_ID BIGINT, P_ERROR_CODE INTEGER DEFAULT 0, P_ERROR_TEXT TEXT DEFAULT NULL, P_PROCESS_AFTER_DELAY BIGINT DEFAULT 0, P_ROW_ID VARCHAR(128) DEFAULT NULL)
RETURNS VOID SECURITY DEFINER
AS $$
 DECLARE
    V_ROWCOUNT BIGINT;
 BEGIN
    IF P_ROW_ID IS NOT NULL THEN
        IF P_ERROR_TEXT IS NOT NULL 
        THEN
            INSERT INTO Q_<SYSID>.STAGES_ERRORS (REQUEST_ID, STAGE, ITERATION, ERROR_DATE, ERROR_CODE, ERROR_TEXT)
            SELECT REQUEST_ID, STAGE, ITERATION, clock_timestamp(), P_ERROR_CODE, P_ERROR_TEXT FROM Q_<SYSID>.STAGES WHERE CTID = P_ROW_ID::TID AND STAGE_DATE = P_STAGE_DATE;

            GET DIAGNOSTICS V_ROWCOUNT = ROW_COUNT;

            IF V_ROWCOUNT = 0 THEN
                INSERT INTO Q_<SYSID>.STAGES_ERRORS (REQUEST_ID, STAGE, ITERATION, ERROR_DATE, ERROR_CODE, ERROR_TEXT)
                SELECT REQUEST_ID, STAGE, ITERATION, clock_timestamp(), P_ERROR_CODE, P_ERROR_TEXT FROM Q_<SYSID>.STAGES_LOG WHERE STAGE_DATE = P_STAGE_DATE AND REQUEST_ID = P_REQUEST_ID
                UNION ALL
                SELECT REQUEST_ID, STAGE, ITERATION, clock_timestamp(), P_ERROR_CODE, P_ERROR_TEXT FROM Q_<SYSID>.STAGES_LOG_ARCHIVE WHERE STAGE_DATE = P_STAGE_DATE AND REQUEST_ID = P_REQUEST_ID;
            END IF;
        END IF;

        UPDATE Q_<SYSID>.STAGES
        SET
            ITERATION = ITERATION + 1,
            PROCESS_AFTER = clock_timestamp() + P_PROCESS_AFTER_DELAY * interval '1 millisecond'
        WHERE CTID = P_ROW_ID::TID AND STAGE_DATE = P_STAGE_DATE;
    ELSE
        IF P_ERROR_TEXT IS NOT NULL
        THEN
            INSERT INTO Q_<SYSID>.STAGES_ERRORS (REQUEST_ID, STAGE, ITERATION, ERROR_DATE, ERROR_CODE, ERROR_TEXT)
            SELECT REQUEST_ID, STAGE, ITERATION, clock_timestamp(), P_ERROR_CODE, P_ERROR_TEXT FROM Q_<SYSID>.STAGES WHERE REQUEST_ID = P_REQUEST_ID AND STAGE_DATE = P_STAGE_DATE;

            GET DIAGNOSTICS V_ROWCOUNT = ROW_COUNT;

            IF V_ROWCOUNT = 0 THEN
                INSERT INTO Q_<SYSID>.STAGES_ERRORS (REQUEST_ID, STAGE, ITERATION, ERROR_DATE, ERROR_CODE, ERROR_TEXT)
                SELECT REQUEST_ID, STAGE, ITERATION, clock_timestamp(), P_ERROR_CODE, P_ERROR_TEXT FROM Q_<SYSID>.STAGES_LOG WHERE STAGE_DATE = P_STAGE_DATE AND REQUEST_ID = P_REQUEST_ID
                UNION ALL
                SELECT REQUEST_ID, STAGE, ITERATION, clock_timestamp(), P_ERROR_CODE, P_ERROR_TEXT FROM Q_<SYSID>.STAGES_LOG_ARCHIVE WHERE STAGE_DATE = P_STAGE_DATE AND REQUEST_ID = P_REQUEST_ID;
            END IF;
        END IF;

        UPDATE Q_<SYSID>.STAGES
        SET
            ITERATION = ITERATION + 1,
            PROCESS_AFTER = clock_timestamp() + P_PROCESS_AFTER_DELAY * interval '1 millisecond'
        WHERE REQUEST_ID = P_REQUEST_ID AND STAGE_DATE = P_STAGE_DATE;
    END IF;
  END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.ROLLBACK_STAGE_PROCESSING_6(P_STAGE_DATE TIMESTAMP WITH TIME ZONE, P_REQUEST_ID BIGINT, P_ERROR_CODE INTEGER, P_ERROR_TEXT TEXT DEFAULT NULL, P_ROW_ID VARCHAR(128) DEFAULT NULL)
RETURNS VOID SECURITY DEFINER
AS $$
  BEGIN
    IF P_ROW_ID IS NOT NULL THEN
        INSERT INTO Q_<SYSID>.STAGES_ERRORS (REQUEST_ID, STAGE, ITERATION, ERROR_DATE, ERROR_CODE, ERROR_TEXT)
        SELECT REQUEST_ID, STAGE, ITERATION, clock_timestamp(), P_ERROR_CODE, P_ERROR_TEXT FROM Q_<SYSID>.STAGES WHERE CTID = P_ROW_ID::TID AND STAGE_DATE = P_STAGE_DATE;
    ELSE
        INSERT INTO Q_<SYSID>.STAGES_ERRORS (REQUEST_ID, STAGE, ITERATION, ERROR_DATE, ERROR_CODE, ERROR_TEXT)
        SELECT REQUEST_ID, STAGE, ITERATION, clock_timestamp(), P_ERROR_CODE, P_ERROR_TEXT FROM Q_<SYSID>.STAGES WHERE REQUEST_ID = P_REQUEST_ID AND STAGE_DATE = P_STAGE_DATE;
    END IF;
  END;
$$ LANGUAGE PLPGSQL;
~
CREATE OR REPLACE FUNCTION Q_<SYSID>.MOVE_STAGE_TO_LOG (P_ROWS INTEGER DEFAULT 1) RETURNS INTEGER SECURITY DEFINER
AS $$
DECLARE
   V_COUNT   INTEGER;
   V_ROWID   TID;
   V_LOCKKEY BIGINT;
BEGIN
   V_COUNT := 0;
   SELECT ('X'||SUBSTR(MD5('Q_<SYSID>_MOVE_STAGE_TO_LOG'), 1, 16))::BIT(64)::BIGINT INTO V_LOCKKEY;

   IF (SELECT PG_TRY_ADVISORY_LOCK(V_LOCKKEY) = TRUE)
   THEN
      BEGIN
         BEGIN
            FOR I IN 1 .. P_ROWS 
            LOOP
               SELECT CTID INTO V_ROWID FROM Q_<SYSID>.STAGES_LOG LIMIT 1;
               IF NOT FOUND THEN
                    EXIT;
               END IF;

               INSERT INTO Q_<SYSID>.STAGES_LOG_ARCHIVE
               (
                      REQUEST_ID,
                      REQUEST_DATE,
                      MSG_ID,
                      EXT_ID,
                      SYS_ID,
                      STAGE_DATE,
                      STAGE,
                      ITERATION,
                      PROCESS_AFTER,
                      DEP_ID,
                      PARENT_DEP_ID,
                      TRANSFER_DATE,
                      FINAL
               )
               SELECT REQUEST_ID,
                      REQUEST_DATE,
                      MSG_ID,
                      EXT_ID,
                      SYS_ID,
                      STAGE_DATE,
                      STAGE,
                      ITERATION,
                      PROCESS_AFTER,
                      DEP_ID,
                      PARENT_DEP_ID,
                      TRANSFER_DATE,
                      FINAL
               FROM Q_<SYSID>.STAGES_LOG
               WHERE CTID = V_ROWID;

               DELETE FROM Q_<SYSID>.STAGES_LOG WHERE CTID = V_ROWID;

               V_COUNT := V_COUNT + 1; 
            END LOOP;
         EXCEPTION
            WHEN OTHERS
            THEN
               NULL;
         END;

         PERFORM PG_ADVISORY_UNLOCK(V_LOCKKEY); 
      END;
   END IF;
   RETURN V_COUNT;
END;
$$ LANGUAGE PLPGSQL;
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.GET_STAGE_VALUE_3_10(VARCHAR, VARCHAR, INTEGER) TO Q_<SYSID>_SVC_ROLE;
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.GET_FINAL_STAGE_VALUE_1_10(BIGINT) TO Q_<SYSID>_SVC_ROLE;
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.PUT_STAGE_VALUE_11_1(VARCHAR, VARCHAR, BIGINT, TEXT, VARCHAR, BIGINT, INTEGER, VARCHAR, VARCHAR, TEXT) TO Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.COMMIT_STAGE_PROCESSING_8(TIMESTAMP WITH TIME ZONE, BIGINT, INTEGER, TEXT, BIGINT, VARCHAR) TO Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.ROLLBACK_STAGE_PROCESSING_6(TIMESTAMP WITH TIME ZONE, BIGINT, INTEGER, TEXT, VARCHAR) TO Q_<SYSID>_SVC_ROLE
~
GRANT EXECUTE ON FUNCTION Q_<SYSID>.MOVE_STAGE_TO_LOG(INTEGER) TO Q_<SYSID>_SVC_ROLE
~
GRANT USAGE ON SCHEMA Q_<SYSID> TO Q_<SYSID>_SVC
~
GRANT Q_<SYSID>_SVC_ROLE TO Q_<SYSID>_SVC
~
